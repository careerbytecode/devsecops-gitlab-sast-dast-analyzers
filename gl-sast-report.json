{"version":"15.1.4","vulnerabilities":[{"id":"a661cfc4133633b9ac11a52a7d7c690938c77f1e965c9c8fa223a2a47f89f2bc","category":"sast","name":"Improper neutralization of special elements used in an OS command ('OS Command Injection')","description":"OS command injection is a critical vulnerability that can lead to a full system\ncompromise as it may allow an adversary to pass in arbitrary commands or arguments\nto be executed.\n\nUser input should never be used in constructing commands or command arguments\nto functions which execute OS commands. This includes filenames supplied by\nuser uploads or downloads.\n\nEnsure your application does not:\n\n- Use user-supplied information in the process name to execute.\n- Use user-supplied information in an OS command execution function which does\nnot escape shell meta-characters.\n- Use user-supplied information in arguments to OS commands.\n\nThe application should have a hardcoded set of arguments that are to be passed\nto OS commands. If filenames are being passed to these functions, it is\nrecommended that a hash of the filename be used instead, or some other unique\nidentifier. It is strongly recommended that a native library that implements\nthe same functionality be used instead of using OS system commands, due to the\nrisk of unknown attacks against third party commands.\n\nWhen specifying the OS command, ensure the application uses the full path\ninformation, otherwise the OS may attempt to look up which process to execute\nand could be vulnerable to untrusted search path vulnerabilities (CWE-426).\n\nExample of safely executing an OS command:\n```\npublic static void executeCommand(String userFileData) throws java.io.IOException {\n    // Generate a random filename, do not use user input\n    String fileName = UUID.randomUUID().toString();\n    // Create a Buffered/FileWriter\n    BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));\n    // Write the user content to our random file\n    writer.write(userFileData);\n    // Close the file to flush contents\n    writer.close();\n    // Create the process builder with a hardcoded path to the binary, and our randomly\ngenerated filename\n    ProcessBuilder processBuilder = new ProcessBuilder(\"/opt/app/path\", fileName);\n    // Start the process\n    Process process = processBuilder.start();\n    // Handle/redirect output of process here\n    // ...\n}\n```\n\nFor more information on OS command injection, see OWASP's guide:\nhttps://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html\n","cve":"semgrep_id:find_sec_bugs.COMMAND_INJECTION-1:11:11","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/com/scalesec/vulnado/Cowsay.java","start_line":11},"identifiers":[{"type":"semgrep_id","name":"find_sec_bugs.COMMAND_INJECTION-1","value":"find_sec_bugs.COMMAND_INJECTION-1"},{"type":"cwe","name":"CWE-78","value":"78","url":"https://cwe.mitre.org/data/definitions/78.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-COMMAND_INJECTION","value":"COMMAND_INJECTION"}]},{"id":"3867709654c87277181345e58bd8518dd5bc800938ae3d464d1ceedc3cb1e2a7","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:49:49","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/com/scalesec/vulnado/User.java","start_line":49},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"b3461b8c887e4b91824a748c55cf93469011eac8ac03b748389a52492c7a828c","category":"sast","name":"Use of a broken or risky cryptographic algorithm (SHA1/MD5)","description":"The application was found using an insecure or risky digest or signature algorithm. Both MD5\nand SHA1 hash algorithms have been found to be vulnerable to producing collisions.\nThis means\nthat two different values, when hashed, can lead to the same hash value. If the application is\ntrying\nto use these hash methods for storing passwords, then it is recommended to switch to a\npassword hashing\nalgorithm such as Argon2id or PBKDF2.\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n\nFor more information on secure password storage see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n","cve":"semgrep_id:find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1:67:67","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/com/scalesec/vulnado/Postgres.java","start_line":67},"identifiers":[{"type":"semgrep_id","name":"find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","value":"find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1"},{"type":"cwe","name":"CWE-327","value":"327","url":"https://cwe.mitre.org/data/definitions/327.html"},{"type":"owasp","name":"A04:2021 - Insecure Design","value":"A04:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-WEAK_MESSAGE_DIGEST_MD5","value":"WEAK_MESSAGE_DIGEST_MD5"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-WEAK_MESSAGE_DIGEST_SHA1","value":"WEAK_MESSAGE_DIGEST_SHA1"}]},{"id":"9cc173e777dad4c3133edd9571112db5cf2ce08dddf599d945e5cbfaa20313a6","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:11:11","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/com/scalesec/vulnado/CowController.java","start_line":11},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"c15f4a67889c8c784cd13c5402906980d26c86f5b6eb871e880c5d3feaabc443","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:15:15","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/com/scalesec/vulnado/LinksController.java","start_line":15},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"c36bb49f4b496b278597113e24ac73590a5135dea4fb3b03d88b2f000812aedc","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:19:19","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/com/scalesec/vulnado/LinksController.java","start_line":19},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]}],"scan":{"analyzer":{"id":"semgrep","name":"Semgrep","url":"https://gitlab.com/gitlab-org/security-products/analyzers/semgrep","vendor":{"name":"GitLab"},"version":"5.25.0"},"scanner":{"id":"semgrep","name":"Semgrep","url":"https://github.com/returntocorp/semgrep","vendor":{"name":"GitLab"},"version":"1.74.0"},"type":"sast","start_time":"2025-01-16T15:40:28","end_time":"2025-01-16T15:40:39","status":"success"}}
